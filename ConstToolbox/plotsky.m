function p_handle = plotsky(az,el,prn_pass,plot_title,spoke_label)

% p_handle = plotsky(az,el,prn,plot_title,spoke_label);
%
% Function to plot the trajectories on a polar sky (azimuth/elevation) plot
% for a single observer. Each arc generated by a satellite is colored and
% labeled with the prn number. This function will use the current figure
% if one is available. Otherwise, a figure will be created. Zoom 
% capability is added to the figure. See help on ZOOM for more information.
% Starting points are not labeled and end points are labeled 
% with 'x'. 
%
% Input:
%   az          - azimuth (-pi to 2*pi rad) (nx1)
%   el          - elevation (-pi/2 to pi/2 rad) (nx1)
%   prn_pass    - [satellite number, pass number], nx1 or nx2 (optional),
%                 pass numbers are computed by PASSDATA. 
%                 if not provided, a single line is drawn
%   plot_title  - title of plot (1xm string) (optional) default = 'Sky Plot'
%   spoke_label - labels for the North, East, South,and West spokes of the 
%                 plot. (4xn string) (optional).  
%                 default = str2mat('N','E','S','W')
% Output:
%   p_handle    - graphics handle to the figure
%
% See also PLOTPASS

% Written by: Jimmy LaMance 11/7/96
% Modified by: Maria Evans 5/5/98
% Copyright (c) 1998 by Constell, Inc.

% functions called: ERR_CHK, PLOTPOLR

%%%%% BEGIN VARIABLE CHECKING CODE %%%%%
% declare the global debug variable
global DEBUG_MODE

% Initialize the output variables
p_handle=[];

% Check the number of input arguments and issues a message if invalid
msg = nargchk(2,5,nargin);
if ~isempty(msg)
  fprintf('%s  See help on PLOTSKY for details.\n',msg);
  fprintf('Returning with empty outputs.\n\n');
  return
end

% check that the size of the prn_pass input is valid, if provided
if nargin < 3,
  prn_pass = zeros(size(plot_data,1),2);
end % if nargin < 3
% Check to make sure the title string is a valid size
if nargin < 4,
  plot_title = ['Sky Plot'];
end % if nargin == 4
if nargin < 5
  spoke_label = str2mat('N','E','S','W');
end % if nargin >= 5

% Get the current Matlab version
matlab_version = version;
matlab_version = str2num(matlab_version(1));

% If the Matlab version is 5.x and the DEBUG_MODE flag is not set
% then set up the error checking structure and call the error routine.
if matlab_version >= 5.0                        
  estruct.func_name = 'PLOTSKY';

  % Develop the error checking structure with required dimension, matching
  % dimension flags, and input dimensions.
  estruct.variable(1).name = 'az';
  estruct.variable(1).req_dim = [901 1];
  estruct.variable(1).var = az;
  estruct.variable(1).type = 'ANGLE_RAD';
  
  estruct.variable(2).name = 'el';
  estruct.variable(2).req_dim = [901 1];
  estruct.variable(2).var = el;
  estruct.variable(2).type = 'ELEVATION_RAD';
  
  estruct.variable(3).name = 'prn_pass';
  estruct.variable(3).req_dim = [901 1; 901 2;];
  estruct.variable(3).var = prn_pass;
  
  % Call the error checking function
  stop_flag = err_chk(estruct);
  
  if stop_flag == 1           
    fprintf('Invalid inputs to %s.  Returning with empty outputs.\n\n', ...
             estruct.func_name);
    return
  end % if stop_flag == 1
end % if matlab_version >= 5.0 & isempty(DEBUG_MODE) 

%%%%% END VARIABLE CHECKING CODE %%%%%

%%%%% BEGIN ALGORITHM CODE %%%%%

% Determine how many satellites are involved and plot them 1 at a time
active_sats = [];     % starting value for the active satellites matrix

prn = prn_pass(:,1);
if size(prn_pass,2)==2,,
  pass = prn_pass(:,2);
else,
  pass = ones(size(prn));
end;

prn_nums = unique(prn);
num_prns = length(prn_nums);

for i = 1:num_prns           % loop over possible prn numnbers
  I = find(prn == prn_nums(i));                      % find the matches
  if ~isempty(I)                                % if there is a match, 
    active_sats = [active_sats prn(I(1))]; % add that prn to the active list
  end % if any(I)
end % for

avail_colors = ['gmycrb'];
num_colors = length(avail_colors);

for i = 1:size(active_sats,2)                % loop over the active satellites
  J = find(prn == active_sats(i));     % all satellites with the same prn number 

  % Determine how many passes for this PRN
  pass_sort = sort(pass(J));
  pass_change = find(diff(pass_sort) ~= 0);
  % create a matrix that has sorted and reduced pass numbers [1 2 4 5 6 8 ... 28]
  pass_nums = [pass_sort(pass_change); pass_sort(length(pass_sort))];
  num_passes = length(pass_nums);

  % verify that some satellites were found
  if any(J)
    label_color = avail_colors(rem(i,num_colors) + 1);  % cycle through colors
    for k = 1:num_passes,
      I = find(prn == active_sats(i) & pass == pass_nums(k));   

      % plot the az/el pairs for this satellite
      p_handle = ...
         plotpolr(az(I),el(I),'-',num2str(active_sats(i)),label_color,spoke_label);
    
      % clear out the I variable
      clear I
    
      % make sure that the hold state is on
      if ishold == 0
        hold on
      end % if ishold == 0
    end;
    
  end % if any(I)

end % for
title(plot_title);
zoom on       

% set the plot label to be Satellite Sky Plot if it is not already named
if isempty(get(gcf,'Name'))==1,
  set(gcf,'Name','Satellite Sky Plot')
end;

hold off

%%%%% END ALGORITHM CODE %%%%%

% end PLOTSKY

function hpol = plotpolr(az,el,line_style,prn_label,label_color,spoke_label)

% hpol = plotpolr(az,el,line_style,prn_label,label_color,spoke_label);
%
% Azimuth-Elevation polar coordinate plot. Plots a line based on azimuth and 
% elevation data with optional inputs for labeling and coloring of the line.
%
% Inputs:
%   az           - azimuth vector (rad) (nx1)
%                   valid values are -2*pi -> 2*pi
%   el           - elevation vector (rad) (nx1)
%                   valid values are -pi/2 -> pi/2
%   line_style   - line style to use for this line (string) (optional). 
%                   These are the Matlab character designations for line styles 
%                   [. o x + - * : -. --], default is the Matlab 'auto'
%   prn_label    - label to identify the az/el line (string) (optional)
%                   default is no label
%   label_color  - color for the line and label (string) (optional).  
%                   These are the Matlab letter designations for colors 
%                   [y m c r g b w k], default is the Matlab 'auto'
%   spoke_label  - labels for the North, East, South,and West spokes of the 
%                   plot. (4xn string) (optional).  
%                   default = str2mat('N','E','S','W')
%                  
% Outputs:
%   hpol         - handle to the plot created
%
% See also PLOTSKY, NED2AZEL, ECEF2NED

% Written by: Jimmy LaMance 11/7/96 
% Copyright (c) 1998 by Constell, Inc.

% functions called: none

%%%%% BEGIN VARIABLE CHECKING CODE %%%%%
% declare the global debug variable
global DEBUG_MODE

% Initialize the output variables
p_handle=[];

% Check the number of input arguments and issues a message if invalid
msg = nargchk(2,6,nargin);
if ~isempty(msg)
  fprintf('%s  See help on PLOTPOLR for details.\n',msg);
  fprintf('Returning with empty outputs.\n\n');
  return
end

% check if the line style is provided, if not use the default of auto
if nargin < 3            % no line style variable is provided
  line_style = 'auto';   % set to auto mode (default)
end % if nargin < 3
  
% check if the prn label is provided, if not use the default of '' (no label)
if nargin < 4            % no prn label variable is provided
  prn_label = '';        % set to '' (default)
end % if nargin < 4

% check if the label color is provided, if not use the default of auto
if nargin < 5            % no line style variable is provided
  label_color = '';      % set to auto mode (default)
end % if nargin < 5 

% check that the input spoke labels are correct dimension or set to the 
% default values
if nargin < 6
  spoke_label = str2mat('N','E','S','W');
end % if nargin >= 6          

% Get the current Matlab version
matlab_version = version;
matlab_version = str2num(matlab_version(1));

% If the Matlab version is 5.x and the DEBUG_MODE flag is not set
% then set up the error checking structure and call the error routine.
if matlab_version >= 5.0                        
  estruct.func_name = 'PLOTPOLR';

  % Develop the error checking structure with required dimension, matching
  % dimension flags, and input dimensions.
  estruct.variable(1).name = 'az';
  estruct.variable(1).req_dim = [901 1];
  estruct.variable(1).var = az;
  estruct.variable(1).type = 'ANGLE_RAD';
  
  estruct.variable(2).name = 'el';
  estruct.variable(2).req_dim = [901 1];
  estruct.variable(2).var = el;
  estruct.variable(2).type = 'ELEVATION_RAD';

  % Call the error checking function
  stop_flag = err_chk(estruct);
  
  if stop_flag == 1           
    fprintf('Invalid inputs to %s.  Returning with empty outputs.\n\n', ...
             estruct.func_name);
    return
  end % if stop_flag == 1
end % if matlab_version >= 5.0 & isempty(DEBUG_MODE) 

%%%%% END VARIABLE CHECKING CODE %%%%%

%%%%% BEGIN ALGORITHM CODE %%%%%

% get current axis and the hold state
cax = gca;
next = lower(get(cax,'NextPlot'));
hold_state = ishold;

% rotate x (az) 90 degrees to line up with the label defined above
az = -az + pi/2;

% convert elevation to degrees (azimuth will stay in radians)
el = el * 180 / pi;

% convert elevation to declination
el = 90 - el;    

% transform data to Cartesian coordinates.
xx = el.*cos(az);
yy = el.*sin(az);

% black out all the data that is not on the grid
% this section of code is here so that the grid is drawn 
% after the points are plotted and blacked out
I_out_plot = find(sqrt(xx.^2 + yy.^2) >= 90);

% if there are points off the plot, black them out (radius of 90 degree in el)
% this is done by setting the polt location to inf which does not show
% on a plot, a nice feature in Matlab
if any(I_out_plot)    
  xx(I_out_plot) = ones(size(I_out_plot,1),1) * inf;
  xy(I_out_plot) = ones(size(I_out_plot,1),1) * inf;;
end % if any(I_out_plot)

% find the last data point
last = size(xx,1);

% put the x/y data pairs on the plot based on user supplied line styles
if strcmp(line_style,'auto')
    
  hpol = plot(xx,yy);              % plot command with auto line style
    
  if strcmp(label_color,'')     % no color provided, let Matlab choose
    % put the end point as an x with a Matlab chosen color
    qte = text(xx(last),yy(last),'x');  
  else                          % color provided, user the user supplied color
    % put the end point as an x with the desired color
    qte = text(xx(last),yy(last),'x','Color',label_color);   
  end % if strcmp(label_color,'')

else     % line style is provided

  if strcmp(label_color,'')     % no color provided, let Matlab choose
    % generate the plot and put the end point as an x with a Matlab chosen color
    if length(xx) > 1
      hpol = plot(xx,yy,line_style);
      qte = text(xx(last),yy(last),'x');    
    end % if length(xx) > 1
  else                          % color provided, user the user supplied color
    % generate the plot and put the end point as an x with the desired color
    if length(xx) > 1
      hpol = plot(xx,yy,line_style,'Color',label_color);
      qte = text(xx(last),yy(last),'x','Color',label_color);   
    end % if length(xx) > 1
 end % if strcmp(label_color,'')

end % if strcmp(line_style,'auto')

% update the current axies
cax = gca;

% set x-axis and y-axis text color
set(cax,'Color','w','XColor','k','YColor','k');

% set the variable tc (used for spoke color) to black to match the axis colors
tc = 'k';

% end point symbols were placed on the last point in the data
% if the end point is determined to be off the plot, then...
if any(I_out_plot)
  I_last = find(I_out_plot == last);
  if any(I_last)                  % need to clear an end symbol
    %qte = text(xx(last),yy(last),'x','Color','k');  % end point symbol is an x
    qte = text(xx(last),yy(last),'x','Color','k');  % end point symbol is an x
  end % if any(I_last)
end % if any(I_out_plot)

% label the line with a satellite number, 
% put the prn number in the middle of the arc
I_in_plot = find(sqrt(xx.^2 + yy.^2) < 90);

% verify that there is a place to put the label and that a 
% valid label is available
if any(I_in_plot) & ~strcmp(prn_label,'')
  index = fix(size(I_in_plot,1) / 2);    % index to point to add label to
  
  if index == 0     % just in case there is only one point that passed
    index = 1; 
  end % if index == 0
               
  % compute location for the label
  x_label_point = xx(I_in_plot(index));
  y_label_point = yy(I_in_plot(index));
  
  qts = text(x_label_point,y_label_point,prn_label,'Color',label_color);         % put the label on
  
  % clear out unneeded variables
  clear I_in_plot index         
  
end % if any(I_in_plot)  

% update the current axies
cax = gca;

% Hold on to current Text defaults, reset them to the
% Axes' font attributes so tick marks use them.
fAngle  = get(cax, 'DefaultTextFontAngle');
fName   = get(cax, 'DefaultTextFontName');
fSize   = get(cax, 'DefaultTextFontSize');
fWeight = get(cax, 'DefaultTextFontWeight');
set(cax, 'DefaultTextFontAngle',  get(cax, 'FontAngle'), ...
    'DefaultTextFontName',   get(cax, 'FontName'), ...
    'DefaultTextFontSize',   get(cax, 'FontSize'), ...
    'DefaultTextFontWeight', get(cax, 'FontWeight') )

% only do grids if hold is off
if ~hold_state

% make a radial grid
  hold on;              
  max_angle = 2*pi;      % 0-360 degrees
  max_radius = 90;       % 0-90 degrees
  hhh=plot([0 max_angle],[0 max_radius],'k');
  v = [get(cax,'xlim') get(cax,'ylim')];
  ticks = length(get(cax,'ytick'));
  delete(hhh);
  
  % check radial limits and ticks
  rmin = 0;    
  rmax = max_radius; 
  rticks = 3;   % force only three rings

% define a circle with pi/50 azmuthal resolution
  th = 0:pi/50:2*pi;
  xunit = cos(th);
  yunit = sin(th);

% now really force points on x/y axes to lie on them exactly
  inds = [1:(length(th)-1)/4:length(th)];
  xunits(inds(2:2:4)) = zeros(2,1);
  yunits(inds(1:2:5)) = zeros(3,1);

  rinc = (rmax-rmin)/rticks;
  for i=(rmin+rinc):rinc:rmax      % control of elevation
    plot(xunit*i,yunit*i,'-','color',tc,'linewidth',1);
    text(0,i+rinc/20,['  ' num2str(abs(i - 90))],  ...
         'verticalalignment','bottom','Color','k' );
  end % for i=(rmin+rinc):rinc:rmax

% plot spokes
  th = (1:6)*2*pi/12;
  th = (1:6)*2*pi/12;
  cst = sin(th); snt = cos(th);    % formualtion of, 0 - N, 90 - E, etc
  cs = [-cst; cst];
  sn = [-snt; snt];
  plot(rmax*cs,rmax*sn,'-','color',tc,'linewidth',1);

% annotate spokes in degrees (except the N S E and W directions)
  rt = 1.1*rmax;
  
  for i = 1:max(size(th))
    if rem(th(i), pi/2) ~= 0
      text(rt*cst(i),rt*snt(i),int2str(i*30), ...
           'horizontalalignment','center', ...
           'EraseMode','none','Color','k');
      if i == max(size(th))
        loc = int2str(0);
      else
        loc = int2str(180+i*30);
      end % if i == max(size(th))
      
      text(-rt*cst(i),-rt*snt(i),loc, ...
           'horizontalalignment','center', ...
           'EraseMode','none','Color','k');
    end % if rem(th(i), pi/2) ~= 0
  end % for i = 1:max(size(th))

% annotate the N,S,E, and W spokes using the string supplied in spoke_label
  th = (0:3)*2*pi/4;
  cst = sin(th); snt = cos(th);    
  
  rt = 1.15*rmax;

  for i = 1:max(size(th))
    text(rt*cst(i),rt*snt(i),spoke_label(i,:), ...
         'horizontalalignment','center', ...
         'EraseMode','none','Color','k');
  end % for i = 1:max(size(th))

  % add a notation that states that the end points are labeled with an x
  gt1 = text(-1.75 * rmax, -1.15 * rmax, '''x'' denotes last point in time');
  gt2 = text(-1.85 * rmax, -1.25 * rmax, 'elevation is 90 degrees at center'); 
  set(gt1,'Color','k');
  set(gt2,'Color','k');

  % set the axis color to white
  set(cax,'color','k');
  set(cax,'XColor','k','YColor','k');
  
  % set viewto 2-D
  view(0,90);

end % if ~hold_state

% Reset defaults.
set(cax, 'DefaultTextFontAngle', fAngle , ...
    'DefaultTextFontName',   fName , ...
    'DefaultTextFontSize',   fSize, ...
    'DefaultTextFontWeight', fWeight );

% reset the axis if not in a hold state
if ~hold_state
  % set the x and y axis to equal so that a circle is formed
  axis('equal');
  
  % force the axis limits (required to show correctly in Matlab 5)
  set(cax,'XLim',[-90 90],'YLim',[-105 110]);          
  
  % hide the axes
  axis('off');
end % if ~hold_state

% reset hold state
if ~hold_state 
  set(cax,'NextPlot',next); 
end % if ~hold_state

% return the handle to the current figure
hpol = gcf;   
set(gcf,'color','w');

%%%%% END ALGORITHM CODE %%%%%

% end PLOTPOLR

